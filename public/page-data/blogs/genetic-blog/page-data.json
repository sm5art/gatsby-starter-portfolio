{"componentChunkName":"component---src-templates-blog-post-js","path":"/blogs/genetic-blog/","result":{"data":{"site":{"siteMetadata":{"title":"Artur Kashperskiy"}},"markdownRemark":{"id":"b1b1f617-e3c4-5a9d-94a3-5aaa66a6f4b4","excerpt":"Link to code for project on github Introduction When approaching a machine learning problem, a clear definition is key. Next, mathematical modeling and‚Ä¶","html":"<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/mFOKdGye7vY?si=sZ30L3uJBAeZhTZl\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen=\"\" style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p><a href=\"https://github.com/sm5art/genetic-pong\">Link to code for project on github</a></p>\n<h1>Introduction</h1>\n<p>When approaching a machine learning problem, a clear definition is key. Next, mathematical modeling and algorithmic optimization come into play to fine-tune the model‚Äôs parameters. In this blog, we‚Äôll delve into one specific type of unsupervised learning: <strong>genetic algorithms</strong>. Introduced by John Holland in 1960, inspired by Charles Darwin‚Äôs theory of evolution, these algorithms have been gaining traction in various fields such as quant finance and various control theory objectives like robotics and also science fields like medicine/and materials. Here, we‚Äôll explore how a genetic algorithm can be applied to the classic game of Pong, allowing us to play it unsupervised. In this post, we‚Äôll first set the context for our problem and then dive into the implementation details later on. This blog assumes some basic knowledge of linear algebra and some basic python programming knowledge.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 589px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5d921bbf2f1190d34b93514116e8251b/86a2c/evolution.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.94594594594595%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAgADBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB6YTzdYx//8QAGxAAAQQDAAAAAAAAAAAAAAAAAgABAzEREzL/2gAIAQEAAQUC35IDclHyNJ7/AP/EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwFn/8QAHBAAAQMFAAAAAAAAAAAAAAAAAQARIQISIIHw/9oACAEBAAY/AhaIch1S/Qt4f//EABwQAQABBAMAAAAAAAAAAAAAAAEAEBEhUUGB8P/aAAgBAQABPyHCJlEaI005svEJuvtPPc3Q/9oADAMBAAIAAwAAABBE3//EABcRAAMBAAAAAAAAAAAAAAAAAAABESH/2gAIAQMBAT8Qgaun/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAgEBPxBsOcv/xAAeEAACAQQDAQAAAAAAAAAAAAABEQAhMYGxQaHB0f/aAAgBAQABPxBH8IkCWIZozD1pKiQP6cPRRZU8EsdGbvEFs/JexoT/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Evolution\"\n        title=\"Evolution\"\n        src=\"/static/5d921bbf2f1190d34b93514116e8251b/86a2c/evolution.jpg\"\n        srcset=\"/static/5d921bbf2f1190d34b93514116e8251b/a80bd/evolution.jpg 148w,\n/static/5d921bbf2f1190d34b93514116e8251b/1c91a/evolution.jpg 295w,\n/static/5d921bbf2f1190d34b93514116e8251b/86a2c/evolution.jpg 589w\"\n        sizes=\"(max-width: 589px) 100vw, 589px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h1>The Problem (The Environment)</h1>\n<p>When I was in college my friend came to me with a really cool project he was working on: he recreated the classic game of pong in python and was showing me how you can have two players playing simultaneously using different keys on the keyboard. He asked me if its possible to recreate an AI in his game and I set out to explore the potential solutions. I thought of a few ideas, you could try to just create a pretty simple program that would tell the opponent paddle to move up and down based on the position of the ball relative to the paddle and figure out the correct parameters but I set out to explore more potential solutions here using genetic algorithms.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/714b8eaa3303055b85ac3e54408446a1/d8536/pong.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAABwIAH/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxABAAMAAAAAAAAAAAAAAAAAAREggf/aAAgBAQABPyEY23//2gAMAwEAAgADAAAAEFAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECExUf/aAAgBAQABPxBA6Glbl0j5WXpOz//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Pong game\"\n        title=\"Pong game\"\n        src=\"/static/714b8eaa3303055b85ac3e54408446a1/1c72d/pong.jpg\"\n        srcset=\"/static/714b8eaa3303055b85ac3e54408446a1/a80bd/pong.jpg 148w,\n/static/714b8eaa3303055b85ac3e54408446a1/1c91a/pong.jpg 295w,\n/static/714b8eaa3303055b85ac3e54408446a1/1c72d/pong.jpg 590w,\n/static/714b8eaa3303055b85ac3e54408446a1/a8a14/pong.jpg 885w,\n/static/714b8eaa3303055b85ac3e54408446a1/fbd2c/pong.jpg 1180w,\n/static/714b8eaa3303055b85ac3e54408446a1/d8536/pong.jpg 1862w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The environment of the game of pong consists of two concepts: the state of the game and the actions that either player can take in the game. The state of the game of pong is outlayed by the display shown the the user the 1280x720 output which is only one valued here since the game is mostly unichannel/unicollor, we can assume a pretty simple game space for the game state. But even here we can abstract more features out of this by knowing that we have memory access to the balls position and players position, we can abstract even more simple features than the game screen which allow for more robust and quicker learning. The actions that could be taken in the game are represented by the mainly three actions/controls the player has at any time while playing the game: moving up, moving down, doing nothing.</p>\n<h1>Modeling The Problem</h1>\n<p>In this section we are solving the sub-problem of coming up with the inputs and outputs of our model such that we get a model that will suit our specific task of figuring out when to move a pong paddle up or down in relation to the game state.</p>\n<p><strong>The problem</strong> - Designing a function that takes any given information from the game state that outputs the ideal action. Mathematically what this model looks like is a function with a domain (input values) that spans the game state and a range (output values) that spans the possible actions.</p>\n<h2>How do we model?</h2>\n<p>A model has input features and outputs which are designed based on what the problem specifies. We will be using linear algebra to drive the ‚Äúunknown‚Äù part of this model.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">i.e. y = Ax+B\nx - game state\ny - outputs\nA, B - unknown</code></pre></div>\n<h2>The game state (inputs)</h2>\n<p>Since the pong game is written in python we have direct memory access to the ball and paddle speed and direction in the x/y direction which we will be using in the engineering of the inputs/game state. The game state will change every frame of the game which will plug into the model to decide the optimal output. The inputs are normalized to reduce weight explosions when optimizing.\n<em>Note: Max Speed and Screen Height are constants defined in the code and could be changed</em></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/78274/inputs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 69.5945945945946%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABU0lEQVR42nWTW0/CQBCFtzx4AVGpjUjZikSwUhVYLWK8PKgk+v9/kTPkq1lrd5KTbXc7Z+ecmRrzNyLWlWBs/seO4FZwYprj0QQIZyRrDASZIBVYwaXgQTBkb8yzxplPotFivRHs8+64+YNnJdkI3tj/FBTknYcqrAg1OoKu4FBwJOhT8QHftD011ieJGio0kPUgULJnQc7+MWddvh0GvN0S7vGc4+lCcI1PjuboWcn+b4VX3JQIRg0eZjRizrnKfoVsxHrqE5bISUiuuqyJTzQhRs4uSY7zhPMJstOQ5BnezEm+Z7V09J3RWVHQC+OT1jvcqlVY+eaQtqYxBUQL5H8xMv3Q2BSeDTFWKOkFf8kAnzNUWDxP60T+2LS9izqMi0PqkuosOZHfFNPwp+TcWHmo8u74MyY0q/R8/GYS4pDkNbKr0VBPp1TVQ9qSbzaQbof+B6bIGh6//ZgrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"The inputs\"\n        title=\"The inputs\"\n        src=\"/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/fcda8/inputs.png\"\n        srcset=\"/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/12f09/inputs.png 148w,\n/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/e4a3f/inputs.png 295w,\n/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/fcda8/inputs.png 590w,\n/static/6d93b6ae8d97963b81e5f4e5e5f5d7d1/78274/inputs.png 644w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>This image is showing us the inputs I have chosen to engineer in to this model from the game state, the v<sub>y</sub>, v<sub>x</sub> variables are retrieved by taking the speeds that are being used actively in the frame in the game shown in the code here. <em>The code is available for download above and <a href=\"https://github.com/sm5art/genetic-pong\">here</a> on github so you can run the pretrained version on your own computer or run the training yourself</em></p>\n<p>ball.py</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Ball(object):\n\t\n\tdef __init__(self, screen,x,y,size,x_speed,y_speed, color):\n\t\t\n\t\tself.screen = screen\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.size = size\n\t\tself.x_speed = x_speed\n\t\tself.y_speed = y_speed\n\t\tself.color = color\n\n\tdef move(self):\n\t\tself.x+=self.x_speed\n\t\tself.y+=self.y_speed\n\t\tif (self.y &lt;= 0 and self.y_speed &lt; 0):\n\t\t\tself.y_speed = -self.y_speed\n\t\telif (self.y+self.size &gt;= HEIGHT and self.y_speed &gt; 0):\n\t\t\tself.y_speed = -self.y_speed\n\t\tself._draw()\n\n\tdef _draw(self):\n\t\tpygame.draw.rect(self.screen, self.color,[self.x,self.y,self.size,self.size])</code></pre></div>\n<p>Similiar with the paddle we can get the variables through the code/memory during gameplay like this.</p>\n<p>paddle_object.py</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class paddle(object):\n\n    def __init__(self,screen,x,y,length,width,player,speed,weights=None):\n        self.length = length\n        self.width = width\n        self.x = x\n        self.y = y\n        self.player = player\n        self.screen = screen\n        self.speed = speed\n        if weights is not None:\n            self.weights = np.array(weights)\n            self.A, self.B, self.C, self.D = format_weight_array(self.weights)\n        else:\n            weights = np.array([1, 1, 1, 1, 1])\n        self.config = {&#39;one&#39;: {&#39;w&#39;: pygame.K_i, &#39;s&#39;: pygame.K_k}, &#39;two&#39;: {&#39;w&#39;:pygame.K_w, &#39;s&#39;:pygame.K_s }}\n\n    def _draw(self, color=(255,255,255)):\n        pygame.draw.rect(self.screen,color,[self.x,self.y,self.width,self.length])\n\n    def _move_down(self, multiplier=1):\n        if self.y+self.length&lt;=HEIGHT:\n            self.y += multiplier*self.speed\n        \n    def _move_up(self, multiplier=1):\n        if self.y &gt;= 0:\n            self.y -= multiplier*self.speed</code></pre></div>\n<h2>The actions (outputs)</h2>\n<p>The outputs for <strong>the problem</strong> is the pong paddle‚Äôs direction of action.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9111b2648fb9883eef9040b2f41fcbb1/d26de/outputs.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAcUlEQVR42m2PWQrAMAhE04WudG+60t7/mB3hBfJR4eEgOqpzzk2iEr1oxEjNmMkjzORBrOSO+Rr9G54FaVTLxImp5RvtWbKExiQayjHaRRtdbLrExC670AuG9sURm4YIFx28U7HEohCv2MSD9vSuLJg+eeoEN1MnMEoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"The outputs\"\n        title=\"The outputs\"\n        src=\"/static/9111b2648fb9883eef9040b2f41fcbb1/fcda8/outputs.png\"\n        srcset=\"/static/9111b2648fb9883eef9040b2f41fcbb1/12f09/outputs.png 148w,\n/static/9111b2648fb9883eef9040b2f41fcbb1/e4a3f/outputs.png 295w,\n/static/9111b2648fb9883eef9040b2f41fcbb1/fcda8/outputs.png 590w,\n/static/9111b2648fb9883eef9040b2f41fcbb1/efc66/outputs.png 885w,\n/static/9111b2648fb9883eef9040b2f41fcbb1/c83ae/outputs.png 1180w,\n/static/9111b2648fb9883eef9040b2f41fcbb1/d26de/outputs.png 2061w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\nHere we have a pretty simple output space which is represented by one scalar value y. If the y value is above a specified threshold constant called c the pong paddle will be coded to move up in the game against the input space. If the y value is below this specified constant c the pong paddle will be programmed to move down. Otherwise in the range between these values just leave the paddle doing nothing for that frame.</p>\n<p>paddle_object.py</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class paddle(object):\n    ....\n    def move_kb(self, color=(255,255,255)):\n        keys = pygame.key.get_pressed()\n        if keys[self.config[self.player][&#39;w&#39;]]:\n            self._move_up()\n        elif keys[self.config[self.player][&#39;s&#39;]]:\n            self._move_down()\n        self._draw(color=color)\n\n    def move_ai(self, ball):\n        X = prepare_features(ball.x_speed, ball.y_speed, ball.y, self.y)\n        decision = nn(self.A, self.B, self.C, self.D, X)\n        if decision &gt; 0.1:\n            self._move_up()\n        elif decision &lt; -0.1:\n            self._move_down()\n        self._draw()</code></pre></div>\n<h2>Algebra of a Neural Network</h2>\n<p>I used a simple neural network with one set of hidden layers to model the behavior of the paddle.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/50952e36ae32e15c2a8db8a81eff6904/587b0/model.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 8.783783783783782%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAU0lEQVR42i3MvQqAMBhD0c9Z8RcsirZD1UUQddHN938rbyHDIZBAzMw6DJiw4EWPHRFe24MSLTLc+JCjVqbOGtlw4cSIFQWcDg8dOuWMgEpdOvU/eBMEfCvSqw8AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"The outputs\"\n        title=\"The outputs\"\n        src=\"/static/50952e36ae32e15c2a8db8a81eff6904/fcda8/model.png\"\n        srcset=\"/static/50952e36ae32e15c2a8db8a81eff6904/12f09/model.png 148w,\n/static/50952e36ae32e15c2a8db8a81eff6904/e4a3f/model.png 295w,\n/static/50952e36ae32e15c2a8db8a81eff6904/fcda8/model.png 590w,\n/static/50952e36ae32e15c2a8db8a81eff6904/efc66/model.png 885w,\n/static/50952e36ae32e15c2a8db8a81eff6904/587b0/model.png 970w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span>\nDimensions of variables</p>\n<p><em>Note: hidden layers is a constant that is chosen and can be changed to improve performance or add more complexity/parameters to the model</em></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">x: 4x1 (game state/domain)\ny: 1x1  (actions/range)\nA: # hidden layers x 4 (unknown weights)\nB: # hidden layers x 1 (unknown bias)\nC: 1 x # hidden layers (unknown weights)\nD: 1x1 (unknown bias)</code></pre></div>\n<p>This is the model I engineered after a few attempts including linear regression. The weights and bias A, B, C, D are all unknown and will be optimized for in the next section of the blog.</p>\n<p>Here is the model code</p>\n<p>model.py</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">import numpy as np\nfrom genetic import Gene\n\ninput_size = Gene.input_size\nhidden_size = Gene.hidden_size\n\ndef forward_model(A, x, C):\n    return np.tanh(np.dot(A, x)+C)\n\n\n\ndef nn(A, B, C, D, x):\n    return np.tanh(np.dot(C, np.tanh(np.matmul(A, x) + B)) + D)\n\n\ndef format_weight_array(array):\n    A = np.array(array[:hidden_size*input_size]).reshape((hidden_size, input_size))\n    B = np.array(array[hidden_size*input_size:hidden_size*(input_size+1)])\n    C = np.array(array[hidden_size*(input_size+1):hidden_size*(input_size+2)])\n    D = np.array(array[hidden_size*(input_size+2)])\n    return A, B, C, D</code></pre></div>\n<h1>The Genetic Algorithm</h1>\n<h2>Why is this even necessary?</h2>\n<p>As I mentioned in the previous section, we have 4 weights and bias terms that we need to optimize for yet we don‚Äôt have a labeled data set that represents what a pong player should do depending on these inputs. This will require the usage of an unsupervised learning algorithm which will evaluate the progress of learning through a different heuristic. The genetic algorithm draws many simularities to the monte carlo method, although it uses extra genetic based heuristics to guide beyond the method of just randomly guessing and checking as monte carlo does to find best parameters (solution) to the problem/model.</p>\n<h2>Basic structure of any genetic algorithm</h2>\n<p>The basic structure of a genetic algorithm contains:</p>\n<ul>\n<li>A chromosome which expresses a possible solution to the problem (parameters) as a easily breedable object in the context of a genetic algorithm. </li>\n<li>A fitness function which takes a chromosome as input and returns a higher value for what we consider is a better solution (make it much more likely to reproduce)</li>\n<li>A population which is just a set of many chromosomes, typically randomly generated initially and bred into subsequent populations</li>\n<li>A selection method which determines how parents are selected for breeding from the population</li>\n<li>A crossover operation which determines how parents combine to produce offspring</li>\n<li>A mutation operation which determines how random deviations manifest themselves</li>\n</ul>\n<h2>What is a chromosome? (context of a genetic algorithim)</h2>\n<p>A chromosome is an abstract representation of the parameters of the model in such a way that each chromosome can be bred with another chromosome to produce another chromosome that has features extracted from the two parent chromosomes to allow for exploration for the solution in the algorithm. In our model above, we are mostly looking at inputs in the range of floating numbers from -1 to 1 and expecting outputs in a similar sort of range of -1 to 1 floating. We must design our chromosome structure to support floating point weights for the A, B, C, D weights in the model such that the ranges will align with the inputs/outputs but also can be stored in a ‚Äúchromsomal‚Äù that can be easily bred. </p>\n<p>Let‚Äôs take a quick look at the code to see more.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;&quot;&quot;\nGene class contains a class to represent a pong paddle&#39;s alleles and to easily convert them \nto decimal numbers so that you can use the values in inference as well as in training the algo\nw/ crossover and mutation.\n&quot;&quot;&quot;\nclass Gene(object):\n    n = 8 # how many alleles should I use to represent one number \n    hidden_size = 16 # how many hidden layer you want, positively correlated w/ size of allele\n    input_size = 4 # how many inputs there are, positively correlated w/ size of allele\n    var = input_size*hidden_size + 2*hidden_size + 1 # total number of variables to account for based on NN model\n    weight_min = -1\n    weight_max = 1\n    def __init__(self, alleles=None):\n        if alleles:\n            self.alleles = alleles\n        else:\n            self.alleles = [random.randint(0, 1) for i in range(Gene.var*Gene.n)]\n\n    # get decimal number array of length var from binary allele representation\n    def numpy_values(self):\n        vals = []\n        for i in range(Gene.var): # the next line looks really complicated but all it does is convert to binary\n            vals.append(          # and then normalize between weight_min and weight_max\n                int(&quot;&quot;.join(\n                    [str(g) for g in self.alleles[i*Gene.n:(i+1)*Gene.n]]), 2) \n                * (Gene.weight_max-Gene.weight_min)/2**Gene.n + Gene.weight_min )\n        return np.array(vals)</code></pre></div>\n<p>Here is a quick diagram showing what the code is doing above. The Gene object is responsible for holding a representation of the weights of the model in an ‚Äúallele‚Äù like format which is structured here as a binary list of 1 and 0s with a specified length based on the amount of variables and precision specified. The reason why we store our weights in this format is to have an easy representation for comparing and breeding between two different Gene objects representing different weights. The numpy_values functions provides a mapping between the allele format stored internally and creating the float representation used in the matrix calculation at runtime to calculate the decision from the game state. This function takes the alleles that were initialized for the amount of inputs and outputs and hidden size of the model and will output the proper floating decimal numbers that will represent the A, B, C, D matrix values.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e81628cae687093be811b9e1b72e923f/0f98f/genestructure.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe6qCmj/xAAWEAADAAAAAAAAAAAAAAAAAAABECD/2gAIAQEAAQUCgL//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAACAwEAAAAAAAAAAAAAAAAAARARITH/2gAIAQEAAT8hyy8Ex8G2P//aAAwDAQACAAMAAAAQ08//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAgIDAAAAAAAAAAAAAAABACERMRBhkf/aAAgBAQABPxDZRACxiu4KbPZV4jNleP/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Gene Binary Structure\"\n        title=\"Gene Binary Structure\"\n        src=\"/static/e81628cae687093be811b9e1b72e923f/1c72d/genestructure.jpg\"\n        srcset=\"/static/e81628cae687093be811b9e1b72e923f/a80bd/genestructure.jpg 148w,\n/static/e81628cae687093be811b9e1b72e923f/1c91a/genestructure.jpg 295w,\n/static/e81628cae687093be811b9e1b72e923f/1c72d/genestructure.jpg 590w,\n/static/e81628cae687093be811b9e1b72e923f/a8a14/genestructure.jpg 885w,\n/static/e81628cae687093be811b9e1b72e923f/fbd2c/genestructure.jpg 1180w,\n/static/e81628cae687093be811b9e1b72e923f/0f98f/genestructure.jpg 1920w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>What is a population?</h2>\n<p>A population is just a set of chromosomes that are bred to produce the next generation. We use the Generation class in our project to manage the population of genes. Below I show the code, where we have an init function that could have genes specified or not. If genes is not specified, we randomly generate a population of genes with a size of the specified parameter initial_population. If it is then we just create this generation with the specified gene objects (usually produced from a subsequent breeding of last generation). The point of this class is to keep track of a lot of gene objects in relation to each other while tracking their fitness so that we can reproduce them into subsequent generations.\nHow is it initialized?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;&quot;&quot;\nThe Generation class contains a class used keep track of the current generation of the training sequence of paddles. \nThe Generation class assumes that you setup the training conditions such that you have one large right paddle that fills up the screen.\n\n\nParams:\n    initial_population (int) - the starting size of your generation 1 paddles\n\n&quot;&quot;&quot;\nclass Generation(object):\n    def __init__(self, initial_population, right_paddle, screen):\n        self.P = initial_population\n        self.right_paddle = right_paddle\n        self.screen = screen\n        self.generation = 0\n        self.init()\n\n    def init(self, genes=None):\n        self.train_paddles = []\n        self.dead = False\n        self.generation += 1\n        if genes:\n            for i in range(len(genes)):\n                color = [100, 100, 100]\n                mod = i%3\n                color[mod] = i % 255\n                a = Train(color, self.screen,SPACING,HEIGHT/2,P_LENGTH,P_WIDTH,&#39;two&#39;,P_SPEED, gene=genes[i])\n                a.one = self.right_paddle\n                self.train_paddles.append(a)\n        else:\n            for i in range(self.P):\n                color = [100, 100, 100]\n                mod = i%3\n                color[mod] = i % 255\n                a = Train(color, self.screen,SPACING,HEIGHT/2,P_LENGTH,P_WIDTH,&#39;two&#39;,P_SPEED)\n                a.one = self.right_paddle\n                self.train_paddles.append(a)</code></pre></div>\n<p>Here is the Train object that is being referenced here which instantiantes a pong paddle with its own ball for training. The training scenario includes many independent paddles battling against a wall on the right side which would bounce the ball back at a random angle. The goal of the gene/train function is to try to hit back the ball as many times against this random wall as possible, being counted by the Generation module.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&quot;&quot;&quot;\nThe train class is a class that represents an instance of the paddles used in the training sequence.\nThe argument to look closely at in the context of the algorithim is the gene Variable which will contain\nthe information that represents the behavior of that paddle.\n&quot;&quot;&quot;\nclass Train(object):\n    def __init__(self, color, screen,x,y,length,width,player,speed, gene=None):\n        self.color = color\n        self.paddle = paddle(screen,x,y,length,width,player,speed)\n        self.ball = Ball(screen,WIDTH/2,HEIGHT/2,20,-5,random.choice([-5, 5]), color)\n        self.dead = False\n        self.fitness = 0\n        if gene:\n            self.g = gene\n            self.F = self.g.numpy_values()\n            self.A, self.B, self.C, self.D = format_weight_array(self.F)\n        else:\n            self.g = Gene()\n            self.F = self.g.numpy_values()\n            self.A, self.B, self.C, self.D = format_weight_array(self.F)\n\n    def move(self, decision):\n        if decision &gt; 0.1:\n            self.paddle._move_up()\n        elif decision &lt; -0.1:\n            self.paddle._move_down()\n        self.paddle._draw(color=self.color)\n\n    def on_update(self):\n        if self.dead:\n            return\n        self.ball.move()\n        if (self.ball.x &lt;= 0 or self.ball.x+self.ball.size/2 &gt;= WIDTH):\n            self.dead = True\n            return\n        if self.check_collision(self.paddle):\n            self.fitness += 1\n        self.check_collision(self.one, train=True)\n        X = prepare_features(self.ball.x_speed, self.ball.y_speed, self.ball.y, self.paddle.y)\n        self.move(nn(self.A, self.B, self.C, self.D, X))\n\n    def check_collision(self, paddle, train=False):\n        if self.ball.collide(pygame.Rect(paddle.x, paddle.y, paddle.width, paddle.length)):\n            self.ball.bounce(MAXSPEED,MAXBOUNCEANGLE, paddle, train=train)\n            return True\n        return False\n\ndef prepare_features(ball_dx, ball_dy, y_ball, y_paddle):\n    return np.array([ball_dy/MAXSPEED, ball_dx/MAXSPEED, (y_ball-y_paddle)/HEIGHT, y_paddle/HEIGHT])</code></pre></div>\n<h2>What is a fitness function?</h2>\n<p>The fitness function takes in a chromosome and returns a value which is used to determine how likely it is for that chromosome to be reproduced into the next generation. The higher the value, the more likely it will be selected as a parent. Here the fitness was counted by the training function for each gene which would count how many times the paddle would successfully hit the ball back towards the wall on the right. The fitness value is updated here in the Train class:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Train(object):\n    ...\n    def on_update(self):\n        if self.dead:\n            return\n        self.ball.move()\n        if (self.ball.x &lt;= 0 or self.ball.x+self.ball.size/2 &gt;= WIDTH):\n            self.dead = True\n            return\n        if self.check_collision(self.paddle):\n            self.fitness += 1 &lt;--------------\n        self.check_collision(self.one, train=True)\n        X = prepare_features(self.ball.x_speed, self.ball.y_speed, self.ball.y, self.paddle.y)\n        self.move(nn(self.A, self.B, self.C, self.D, X))</code></pre></div>\n<h2>What is a selection function?</h2>\n<p>The selection function takes in a population and returns a subset of the population which are the parents of the next generation. It is up to you how you implement this but we recommend using a tournament selection with elitism to select the best chromosomes from the previous generation. This would let a generation of Train classes of many different genes run for as long as until the last paddle dies (ball falls through it) or until many of the paddles reach the maximum fitness score of 40. Once we reach the end, we simply choose the top genes from the pool with the highest fitness and breed those into the next generation. Here is the code in the Generation class that handles the selection of the genes into the subsequent generations:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Generation(object):\n    ...\n    # this method returns a new generation of those who had the best fitness of the dead paddles\n    # it choses the highest two fitness scores and crossbreeds these two\n    def selection(self):\n        if not self.dead:\n            return\n        new_generation = []\n        fitness = [(i, paddle.fitness) for i, paddle in enumerate(self.train_paddles)]\n        fitness = sorted(fitness, key=lambda x: x[1])\n        top_n_n = 40\n        fit_list = fitness[-top_n_n:]\n        random.shuffle(fit_list)\n        top_n = top_n_n//2\n        for i in range(top_n):\n            myself = self.train_paddles[fit_list.pop()[0]].g\n            mate = self.train_paddles[fit_list.pop()[0]].g\n            son = myself.crossover(mate, n_children=20) # woah calm down there assuming genders\n            new_generation += son\n        self.init(genes=new_generation)</code></pre></div>\n<h2>What is a crossover function?</h2>\n<p>The crossover function takes in two parent chromosomes and returns two child chromosomes. The parents are selected by the selection function, so you can use any method to select them.\nHere is the code describing the crossover function:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Gene(object):\n    ...\n    def _crossover(self, other):\n        alleles = []\n        for i in range(Gene.var*Gene.n):\n            if random.randint(0, 1) &gt; 0:\n                alleles.append(self.alleles[i])\n            else:\n                alleles.append(other.alleles[i])\n        alleles = self._mutate(alleles)\n        return Gene(alleles=alleles)\n\n    #returns list of children (Gene object)\n    # crossover will create crossover with the self and other for a total of n_children times \n    # returns a list of Genes in size n_children\n    def crossover(self, other, n_children=50):\n        lst = []\n        for i in range(n_children):\n            lst.append(self._crossover(other))\n        return lst</code></pre></div>\n<p>Here is a diagram describing the crossover logic in the function above on how two parent genes crossover to form a child gene:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/37f8ccb2fe017387bb60deed7a0453b3/0f98f/crossover.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.08108108108109%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAd0Fkj//xAAWEAEBAQAAAAAAAAAAAAAAAAABEAD/2gAIAQEAAQUCrif/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAbEAABBAMAAAAAAAAAAAAAAAAAARARMSFBYf/aAAgBAQABPyHdEcEMaFy3/9oADAMBAAIAAwAAABBQD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABoQAQEBAQADAAAAAAAAAAAAAAERACEQMWH/2gAIAQEAAT8QGun73RHPTCB4bkDW+P/Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"crossover function\"\n        title=\"crossover function\"\n        src=\"/static/37f8ccb2fe017387bb60deed7a0453b3/1c72d/crossover.jpg\"\n        srcset=\"/static/37f8ccb2fe017387bb60deed7a0453b3/a80bd/crossover.jpg 148w,\n/static/37f8ccb2fe017387bb60deed7a0453b3/1c91a/crossover.jpg 295w,\n/static/37f8ccb2fe017387bb60deed7a0453b3/1c72d/crossover.jpg 590w,\n/static/37f8ccb2fe017387bb60deed7a0453b3/a8a14/crossover.jpg 885w,\n/static/37f8ccb2fe017387bb60deed7a0453b3/fbd2c/crossover.jpg 1180w,\n/static/37f8ccb2fe017387bb60deed7a0453b3/0f98f/crossover.jpg 1920w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>What is a mutation function?</h2>\n<p>The mutation function takes in a chromosome and returns a new chromosome which is a mutated version of the original one. This is used above in the crossover to introduce some randomness during breeding which allows for more exploration during training.\nHere is the code:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Gene(object):\n    ...\n    # default chance of mutation is 1%\n    def _mutate(self, alleles, chance=0.01):\n        new_alleles = []\n        for i in range(Gene.var*Gene.n):\n            if random.random() &lt; chance and i % Gene.n != 0:\n                stored = new_alleles.pop()\n                new_alleles.append(alleles[i])\n                new_alleles.append(stored)\n            else:\n                new_alleles.append(alleles[i])\n        return new_alleles</code></pre></div>\n<h1>References</h1>\n<ol>\n<li><a href=\"https://github.com/Sarthak-Rijal/goodpong\">https://github.com/Sarthak-Rijal/goodpong</a> </li>\n<li><a href=\"https://en.wikipedia.org/wiki/Genetic_algorithm\">https://en.wikipedia.org/wiki/Genetic_algorithm</a> </li>\n<li><a href=\"https://www.geeksforgeeks.org/genetic-algorithms/\">https://www.geeksforgeeks.org/genetic-algorithms/</a></li>\n</ol>","frontmatter":{"title":"Machine Playing Pong Unsupervised with Genetic Algorithms üß¨","date":"June 24, 2024","description":"Building an unsupervised genetic learning algorithm that learns to play pong like atari in 15 minutes in Python."}}},"pageContext":{"slug":"blogs/genetic-blog/","previous":null,"next":null}},"staticQueryHashes":["1561777781","426816048","63159454"]}